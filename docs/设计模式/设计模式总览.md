# 设计模式总览

> "每一个模式描述来了一个在我们周围不断重复发生的问题，"


## 从面向对象谈起

**底层思维**：向下，如何把握机器底层从微观理解对象构造

+ 语言构造（语法）
+ 编译转换
+ 内存模型
+ 运行时机制


**抽象思维**： 向上，如何将我们的周围世界抽象为程序代码

+ 面向对象
+ 组件封装
+ 设计模式
+ 架构模式

### 深入理解面向对象

**向下**： 深入理解三大面向对象机制

+ 封装：隐藏内部实现ß
+ 继承：复用现有代码
+ 多态：改写对象行为

**向上**：深刻把握面向对象机制所带来的抽象的意义，理解如何使用这些机制来表达现实世界，掌握什么事"好的面向对象设计"


软件复杂的原因在于：**变化**，解决**变化**大概有两种方式：分解与抽象

+ 分解：人们面对复杂性有一个常见的做法：即分而治之，将大问题分解为多个小问题，将负载问题分解为多个简单问题；
+ 抽象：更高层次来讲，人们处理复杂性有一个通用的技术，即抽象，由于不能掌握全部的复杂对象，我们选择忽略它的非本质细节，而去处理泛化和理想化了的对象模型；

### 软件设计的目标

软件设计的金科玉律：**复用**


## 推荐书籍

+ 《设计模式 可复用面向对象软件的基础》


## 个人思考

### 思考1： 分解与抽象

分解与抽象在实际开发中的体现在于“责任问题”，即某个方法或者函数应该被谁来调用问题。 举例来说，你要在画板上画出 **Line**、**Rectangle**,这个 **Draw**应该由谁来处理


### 思考2：复用

很多人简单的理解为“Don't Repeat yourself”，所以将一个方法或者函数搞的及其的复杂，后续维护简直成了"屎上雕花"，造成后来改又不敢改，动又不敢动的问题


### 思考3: 抽象

尝试过很多次的抽象，但是在具体实现中，又会遇到各种的问题, 抽象过后，对上层接口来说，就是抽象的类型，如果需要针对具体类型进行特殊处理，改如何进行操作。

**ChatGPT**给了几个解决办法

1. 如果是通用抽象，在抽象类里面，例如 Shape 里面增加 Draw 方法
2. 访问者设计模式，使用不同的 Visitor 进行处理 -- 如果特殊处理的行为比较多，访问者的模式就会显得有些复杂
    ```
    interface Shape {
        void accept(ShapeVisitor visitor);
    }

    class Circle implements Shape {
        double radius = 5;

        @Override
        public void accept(ShapeVisitor visitor) {
            visitor.visit(this);
        }
    }

    class Rectangle implements Shape {
        double width = 4, height = 3;

        @Override
        public void accept(ShapeVisitor visitor) {
            visitor.visit(this);
        }
    }

    // 访问者接口
    interface ShapeVisitor {
        void visit(Circle c);
        void visit(Rectangle r);
    }

    // 具体访问者实现：计算面积
    class AreaCalculator implements ShapeVisitor {
        @Override
        public void visit(Circle c) {
            double area = Math.PI * c.radius * c.radius;
            System.out.println("Circle area: " + area);
        }

        @Override
        public void visit(Rectangle r) {
            double area = r.width * r.height;
            System.out.println("Rectangle area: " + area);
        }
    }

    ```
 3. Map 映射方法
