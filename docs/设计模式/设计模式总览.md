# 设计模式总览

> "每一个模式描述来了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动"


## 从面向对象谈起

**底层思维**：向下，如何把握机器底层从微观理解对象构造

+ 语言构造（语法）
+ 编译转换
+ 内存模型
+ 运行时机制


**抽象思维**： 向上，如何将我们的周围世界抽象为程序代码

+ 面向对象
+ 组件封装
+ 设计模式
+ 架构模式

### 深入理解面向对象

**向下**： 深入理解三大面向对象机制

+ 封装：隐藏内部实现ß
+ 继承：复用现有代码
+ 多态：改写对象行为

**向上**：深刻把握面向对象机制所带来的抽象的意义，理解如何使用这些机制来表达现实世界，掌握什么事"好的面向对象设计"


软件复杂的原因在于：**变化**，解决**变化**大概有两种方式：分解与抽象

+ 分解：人们面对复杂性有一个常见的做法：即分而治之，将大问题分解为多个小问题，将负载问题分解为多个简单问题；
+ 抽象：更高层次来讲，人们处理复杂性有一个通用的技术，即抽象，由于不能掌握全部的复杂对象，我们选择忽略它的非本质细节，而去处理泛化和理想化了的对象模型；

### 软件设计的目标

软件设计的金科玉律：**复用**

## 重新认识面向对象

### 理解隔离变化

+ 从宏观层面来看，面向对象的构建方式更能适应软件的变化，能将变化带来的影响减为最最小

### 各司其职

+ 从微观层面来看，面向对象的方式更强调各个类的”责任“
+ 由于需求变化导致的新增类型不应该影响原来类型的视线---是所谓各负其责

### 对象是什么？ 

+ 从语言实现层面来看，对象封装了代码和数据
+ 从规格层面讲，对象是一系列可被使用的公共接口
+ 从概念层面讲, 对象是某种拥有责任的抽象


## 面向对象设计原则

### 1. 依赖倒置原则（DIP）

+ 高层模块（稳定）不应该依赖于低层模块（变化）， 二者都应该依赖于抽象（稳定）
    + MainFrame 依赖于 Shape， Line 和 Rectangle 依赖于 Shape
+ 抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖于抽象（稳定）
    + Shape 不应该含有Line 和 Shape 的实现细节

### 2. 开放封闭原则（OCP）

+ 对扩展开发，对更改封闭
+ 类模块应该是可扩展的，但是不可修改

### 3. 单一职责原则（SRP）

+ 一个类应该仅有一个引起它变化的原因
+ 变化的方向隐含着类的责任

### 4. 里氏替换原则（LSP）

+ 子类必须能够替换它们的基类（IS-A）
+ 继承表达类型的抽象

### 5. 接口隔离原则（ISP）

+ 不应该强迫客户程序依赖它们不用的方法；
+ 接口应该小而完备

### 6. 优先使用对象组合，而不是类继承

+ 类继承通常为”白箱复用“，对象组合通常为”黑箱复用“；
+ 继承在某种程度上破坏了封装性，子类父类耦合度高；
+ 而对象组合只要求被组合的对象具有良好定义的接口，耦合度低；

### 7. 封装变化点

+ 使用封装来创建对象之间的分界层，让设计者可以在分界层一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合

### 8.针对接口编程，而不是针对实现编程

+ 不将变量类型声明为某个特定的具体类，而是声明为某个具体类
+ 客户程序无需获知对象的具体类型，只需要知道对象所具有的接口；
+ 减少系统中各部分的依赖关系，从而实现 ”高内聚、松耦合“的类型设计方法；


## 推荐书籍

+ 《设计模式 可复用面向对象软件的基础》
+ 《重构-改善既有代码的设计》
+ 《重构与模式》

## 个人思考

### 思考1： 分解与抽象

分解与抽象在实际开发中的体现在于“责任问题”，即某个方法或者函数应该被谁来调用问题。 举例来说，你要在画板上画出 **Line**、**Rectangle**,这个 **Draw**应该由谁来处理


### 思考2：复用

很多人简单的理解为“Don't Repeat yourself”，所以将一个方法或者函数搞的及其的复杂，后续维护简直成了"屎上雕花"，造成后来改又不敢改，动又不敢动的问题


### 思考3: 抽象

尝试过很多次的抽象，但是在具体实现中，又会遇到各种的问题, 抽象过后，对上层接口来说，就是抽象的类型，如果需要针对具体类型进行特殊处理，改如何进行操作。

**ChatGPT**给了几个解决办法

1. 如果是通用抽象，在抽象类里面，例如 Shape 里面增加 Draw 方法
2. 访问者设计模式，使用不同的 Visitor 进行处理 -- 如果特殊处理的行为比较多，访问者的模式就会显得有些复杂
    ```
    interface Shape {
        void accept(ShapeVisitor visitor);
    }

    class Circle implements Shape {
        double radius = 5;

        @Override
        public void accept(ShapeVisitor visitor) {
            visitor.visit(this);
        }
    }

    class Rectangle implements Shape {
        double width = 4, height = 3;

        @Override
        public void accept(ShapeVisitor visitor) {
            visitor.visit(this);
        }
    }

    // 访问者接口
    interface ShapeVisitor {
        void visit(Circle c);
        void visit(Rectangle r);
    }

    // 具体访问者实现：计算面积
    class AreaCalculator implements ShapeVisitor {
        @Override
        public void visit(Circle c) {
            double area = Math.PI * c.radius * c.radius;
            System.out.println("Circle area: " + area);
        }

        @Override
        public void visit(Rectangle r) {
            double area = r.width * r.height;
            System.out.println("Rectangle area: " + area);
        }
    }

    ```
3. Map 映射方法